import os
import shutil
from typing import List
from fastapi import APIRouter, HTTPException, Depends, status, UploadFile, File, BackgroundTasks
from bson import ObjectId
from datetime import datetime

from ..models import CaseCreate, CaseInDB, UserInDB, CaseTimelineEntry, CaseStatus, CaseFile, CaseUpdate
from ..database import cases_collection
from ..auth import get_current_active_user, require_role
from ..tasks import send_hearing_reminder

router = APIRouter()
UPLOAD_DIRECTORY = "backend/uploads"

if not os.path.exists(UPLOAD_DIRECTORY):
    os.makedirs(UPLOAD_DIRECTORY)

async def generate_case_id() -> str:
    # Get the count of cases to generate a simple sequential ID
    count = await cases_collection.count_documents({})
    return f"CTP-{str(count + 1).zfill(5)}"

@router.post("/", response_model=CaseInDB, status_code=status.HTTP_201_CREATED)
async def create_case(
    case: CaseCreate,
    current_user: UserInDB = Depends(get_current_active_user)
):
    case_id = await generate_case_id()
    
    # Create initial timeline entry
    initial_timeline_entry = CaseTimelineEntry(status="Filed", notes="Case created.")
    
    case_doc = case.dict()
    case_doc["case_id"] = case_id
    case_doc["created_by_email"] = current_user.email
    case_doc["timeline"] = [initial_timeline_entry.dict()]
    case_doc["files"] = []
    
    new_case = await cases_collection.insert_one(case_doc)
    created_case = await cases_collection.find_one({"_id": new_case.inserted_id})
    
    return CaseInDB(**created_case)

@router.get("/", response_model=List[CaseInDB])
async def list_cases(current_user: UserInDB = Depends(get_current_active_user)):
    query = {}
    if current_user.role == "client":
        # Clients can only see cases where they are the client
        query = {"client_name": current_user.full_name} # A bit simplistic, assumes client_name matches user full_name
    elif current_user.role == "lawyer":
        # Lawyers see cases assigned to them
        query = {"assigned_lawyer_email": current_user.email}
    # Admins see all (empty query)

    cases_cursor = cases_collection.find(query)
    cases = await cases_cursor.to_list(length=100)
    return [CaseInDB(**case) for case in cases]

@router.get("/{case_id}", response_model=CaseInDB)
async def get_case(case_id: str, current_user: UserInDB = Depends(get_current_active_user)):
    case = await cases_collection.find_one({"_id": ObjectId(case_id)})
    if not case:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Case not found")
    
    # Simple auth check (can be expanded)
    if (current_user.role == "client" and case["client_name"] != current_user.full_name) or \
       (current_user.role == "lawyer" and case["assigned_lawyer_email"] != current_user.email):
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not authorized to view this case")

    return CaseInDB(**case)

@router.put("/{case_id}", response_model=CaseInDB)
async def update_case(
    case_id: str, 
    case_update: CaseUpdate,
    background_tasks: BackgroundTasks,
    current_user: UserInDB = Depends(require_role("lawyer")) # Only lawyers or admins can update
):
    existing_case = await cases_collection.find_one({"_id": ObjectId(case_id)})
    if not existing_case:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Case not found")

    update_data = case_update.dict(exclude_unset=True)
    
    if "status" in update_data and update_data["status"] != existing_case["status"]:
        # Add a new timeline entry if status changes
        new_timeline_entry = CaseTimelineEntry(status=update_data["status"], notes="Status updated.")
        update_data["$push"] = {"timeline": new_timeline_entry.dict()}
        
        # If status is "Hearing Scheduled", schedule a reminder
        if update_data["status"] == "Hearing Scheduled":
            # This is simplified; you'd likely have a hearing_date field in CaseUpdate
            hearing_date_str = datetime.now().strftime("%Y-%m-%d %H:%M") # Placeholder
            background_tasks.add_task(
                send_hearing_reminder,
                existing_case["assigned_lawyer_email"],
                existing_case["case_id"],
                existing_case["client_name"],
                hearing_date_str
            )

    if "$push" in update_data:
        # If we have a $push, we need to handle the update differently
        push_data = update_data.pop("$push")
        await cases_collection.update_one(
            {"_id": ObjectId(case_id)},
            {"$set": update_data, "$push": push_data}
        )
    else:
        await cases_collection.update_one(
            {"_id": ObjectId(case_id)},
            {"$set": update_data}
        )

    updated_case = await cases_collection.find_one({"_id": ObjectId(case_id)})
    return CaseInDB(**updated_case)

@router.delete("/{case_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_case(case_id: str, current_user: UserInDB = Depends(require_role("admin"))):
    delete_result = await cases_collection.delete_one({"_id": ObjectId(case_id)})
    if delete_result.deleted_count == 0:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Case not found")
    return

@router.post("/{case_id}/upload", response_model=CaseInDB)
async def upload_case_file(
    case_id: str, 
    file: UploadFile = File(...), 
    current_user: UserInDB = Depends(get_current_active_user)
):
    case = await cases_collection.find_one({"_id": ObjectId(case_id)})
    if not case:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Case not found")

    # Create a specific directory for the case
    case_upload_dir = os.path.join(UPLOAD_DIRECTORY, case_id)
    if not os.path.exists(case_upload_dir):
        os.makedirs(case_upload_dir)
    
    file_path = os.path.join(case_upload_dir, file.filename)
    
    try:
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
    finally:
        file.file.close()

    # Store a relative URL to be served statically
    file_url = f"/uploads/{case_id}/{file.filename}"
    
    new_file = CaseFile(filename=file.filename, url=file_url)
    
    await cases_collection.update_one(
        {"_id": ObjectId(case_id)},
        {"$push": {"files": new_file.dict()}}
    )
    
    updated_case = await cases_collection.find_one({"_id": ObjectId(case_id)})
    return CaseInDB(**updated_case)
